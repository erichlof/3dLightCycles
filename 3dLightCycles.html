<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>3dLightCycles</title>
	<style>

		body {
			background-color: rgb(0, 0, 0);
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
		
	</style>
</head>

<body>
	
	<div id="banner" style="position:fixed; left:0; right:0; top:20%; text-align:center; z-index: 10;
                               font-size:40px; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		<!-- Loading... -->
	</div>
	
	<div id="gameover" style="position:fixed; left:0; right:0; top:25%; text-align:center; z-index: 10;
                               font-family:arial; font-type:bold; color:rgb(255,255,255);">
	</div>
	
	<div id="container"></div>

	<div id="debug1" style="position:fixed; left:2%; top:2%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		
	</div>
	
	<div id="help" style="position:fixed; left:2%; bottom:7%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		3dLightCycles
	</div>
	
	<div id="help1" style="position:fixed; left:2%; bottom:4%; font-family:arial; font-size:10px; color:grey;">
		Desktop: Mouse to rotate | Esc: exit
	</div>

	<div id="help2" style="position:fixed; left:2%; bottom:1%; font-family:arial; font-size:10px; color:grey;">
		Mobile: Swipe to rotate
	</div>
	
	<div id="score" style="position:fixed; right:3%; top:1%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		0
	</div>
	
	<div id="sound" style="position:fixed; right:3%; top:14%; font-family:arial; font-type:bold; color:rgb(70,70,70); border:thin solid;">
		Sound: Off
	</div>	

	 <script src="js/three.min.js"></script> 
	<!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script> -->
	<script src="js/ShadowMesh.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
	<script src="js/threex.FirstPersonControls.js"></script>
	<script src="js/virtualButtonJoystick.js"></script>
	<script src="js/threex.GameTimer.js"></script>
	<script src="js/howler.js"></script>
	<script src="js/3dLightCyclesVariables.js"></script>
	
	<script>
		
		
		function initLevel() {
			
			playerAlive = true;
			
			// initial starting position
			cycle.position.set(-testSquare, 0, testSquare);
			
			// initial heading and rotation
			cycleDirection = NORTH;
			cycleHeadingVector.copy(northVector);
			
			// trigger a 'dummy' cycleJustTurned event to start new blended trail formation
			cycleJustTurned = true;
			// spawn the cycle's first jet trail
			spawnTrail();
			
			// for debug flyCam
			cameraControlsObject.position.set(-5,10,26);
			
			// for debugging jet trail, look west
			//cameraControlsYawObject.rotation.y = 1.6;
			//joystick.previousRotationY = 1.6;
			
			// look slightly downward
			cameraControlsPitchObject.rotation.x = -0.5;
			joystick.previousRotationX = -0.5;
			
			// for initial 3rd person view, pull the camera back a little
			//camera.translateZ(cameraDistance);
			
			animate();
			
		} // end function initLevel()
		

		function animate() {
			
			// keep looping through animate()
			requestAnimationFrame(animate);
			// store how much time has passed since the last animation frame
			frameTime = clock.getDelta();
			
			// RESPOND TO PLAYER INPUT ///////////////////////////////////////////////////////////////////////////////////////////
			
			// check if joystick Stick is being moved
			if (playerAlive) {
				// if not playing on desktop, get the rotation from the mobile-touch virtual Joystick
				if (!mouseControl) {
					
					cameraControlsYawObject.rotation.y = joystick.previousRotationY - joystick.deltaX() * 0.005;
					cameraControlsPitchObject.rotation.x = joystick.previousRotationX - joystick.deltaY() * 0.005;
					// clamp the camera's vertical movement (around the x-axis) to the 'ceiling' and 'floor',
					// so you can't accidentally flip the camera upside down
					cameraControlsPitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, cameraControlsPitchObject.rotation.x ) );
				
				}

			}
			
			// this gives us a vector in the direction that the camera is pointing,
			// which will be useful for moving the camera 'forward' and shooting projectiles in that direction
			controls.getDirection(cameraRotationVector);
			cameraRotationVector.normalize();
			
			// the following gives us a rotation quaternion (4D vector), which will be useful for 
			// rotating scene objects to match the camera's rotation
			camera.getWorldQuaternion(cameraWorldQuaternion);
			
			// allow flying camera forward
			if ( playerAlive && (joystick.button2Pressed || keyboard.pressed('space')) ) {
				
				cameraControlsObject.localToWorld(cameraControlsObject.position);
				cameraControlsObject.translateOnAxis(cameraRotationVector, 20 * frameTime);
				cameraControlsObject.worldToLocal(cameraControlsObject.position);
				
			}
			
			
			
			
			// GAME UPDATE AND LOGIC /////////////////////////////////////////////////////////////////////////////////////////////
			
			
			
			// CHECK FOR AND HANDLE CYCLE TURNING
			
			// for debugging trails only - normally this will happen when player initiates turn
			
			// turning EAST
			if (cycle.position.z < -testSquare) { 
				
				cycle.position.z = -testSquare + 0.01; // won't actually need this
				
				cycleDirection = EAST;
				cycleHeadingVector.copy(eastVector);
				rotateCycleRight = true;
				trailBeginning.rotation.y = east_Y_Rotation;
				cycleJustTurned = true;
				// make final measurement before we cap off the current wall and turn the cycle
				trailLength = Math.abs(trailSpawnZ - cycle.position.z) + 0.001;//+0.001
				trailScale = trailLength / 10;
				
				northSouthTrail[northSouthTrailCount].scale.set(1, 1, trailScale);
				northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ - (trailLength / 2);
				
				// get the correct current matrix so shadows match exactly
				northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
				northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );
				
				spawnTrail();
				
				// snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = east_Y_Rotation;
				//joystick.previousRotationY = east_Y_Rotation;
				
			}
			// turning SOUTH
			if (cycle.position.x > testSquare) {
				
				cycle.position.x = testSquare - 0.01; // won't actually need this
				
				cycleDirection = SOUTH;
				cycleHeadingVector.copy(southVector);
				rotateCycleRight = true;
				trailBeginning.rotation.y = south_Y_Rotation;
				cycleJustTurned = true;
				// make final measurement before we cap off the current wall and turn the cycle
				trailLength = Math.abs(cycle.position.x - trailSpawnX) + 0.001;//+0.001
				trailScale = trailLength / 10;
				
				eastWestTrail[eastWestTrailCount].scale.set(trailScale, 1, 1);
				eastWestTrail[eastWestTrailCount].position.x = trailSpawnX + (trailLength / 2);
				
				// get the correct current matrix so shadows match exactly
				eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
				eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );
				
				spawnTrail();
				
				// snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = south_Y_Rotation;
				//joystick.previousRotationY = south_Y_Rotation;
				
			}
			// turning WEST
			if (cycle.position.z > testSquare) {
				
				cycle.position.z = testSquare - 0.01; // won't actually need this
				
				cycleDirection = WEST;
				cycleHeadingVector.copy(westVector);
				rotateCycleRight = true;
				trailBeginning.rotation.y = west_Y_Rotation;
				cycleJustTurned = true;
				// make final measurement before we cap off the current wall and turn the cycle
				trailLength = Math.abs(cycle.position.z - trailSpawnZ) + 0.001;//+0.001
				trailScale = trailLength / 10;
				
				northSouthTrail[northSouthTrailCount].scale.set(1, 1, trailScale);
				northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ + (trailLength / 2);
				
				// get the correct current matrix so shadows match exactly
				northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
				northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );
				
				spawnTrail();
				
				// snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = west_Y_Rotation;
				//joystick.previousRotationY = west_Y_Rotation;
				
				// for testing trails
				testSquare += 5; 
				
			}
			// turning NORTH
			if (cycle.position.x < -testSquare) {
				
				cycle.position.x = -testSquare + 0.01; // won't actually need this
				
				cycleDirection = NORTH;
				cycleHeadingVector.copy(northVector);
				rotateCycleRight = true;
				trailBeginning.rotation.y = north_Y_Rotation;
				cycleJustTurned = true;
				// make final measurement before we cap off the current wall and turn the cycle
				trailLength = Math.abs(trailSpawnX - cycle.position.x) + 0.001;//+0.001
				trailScale = trailLength / 10;
				
				eastWestTrail[eastWestTrailCount].scale.set(trailScale, 1, 1);
				eastWestTrail[eastWestTrailCount].position.x = trailSpawnX - (trailLength / 2);
				
				// get the correct current matrix so shadows match exactly
				eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
				eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );
				
				spawnTrail();
				
				// snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = north_Y_Rotation;
				//joystick.previousRotationY = north_Y_Rotation;
				
			}
			
			
			
			
			
			// UPDATE TRAILS ///////////////////////////////////////////////////////////////////////////////////////////////
			
			// based on cycleDirection, update the current trail
			
			if (cycleDirection == NORTH) {
				
				// record the distance between the cycle and its trail spawn point when it turned or started the match 
				cycleTrailSpawnDistance = Math.abs(trailSpawnZ - cycle.position.z) + 0.001;

				if (animatingBlendedTrail) {
					// if the cycle is far enough away from the active trail spawn point, 
					// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
					if (cycleTrailSpawnDistance > 1)
						trailBeginningLength = cycleTrailSpawnDistance - 1;
					else 
						trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet

					// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
					if (trailBeginningLength > 2.1) {
						trailBeginningLength = 2.1;//2.1 instead of 2 to cover up light vertical line segment
						animatingBlendedTrail = false;
					}

					trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
					trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
				}

				// make blended beginning trail closely follow cycle's rear wheel                                                         
				trailBeginning.position.set( cycle.position.x, halfTrailHeight, cycle.position.z + 1 + (trailBeginningLength / 2) );
				// get the correct current matrix so shadows match exactly
				trailBeginning.updateMatrixWorld(true);
				blendedBeginningTrailShadow.update( groundPlane, lightPosition4D );

				// update main trail wall

				// if the cycle is far enough away from the active trail spawn point, 
				// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
				if (cycleTrailSpawnDistance > 3)
					trailLength = cycleTrailSpawnDistance - 3;
				else 
					trailLength = 0.001; // else, the trail doesn't have any noticable length yet

				
				
				// when trail wall segment reaches maximum 10 unit length, clamp it.
				// also when this happens, it's time to spawn another trail segment
				if (trailLength > 10) {

					trailLength = 10;
					// cap off current trail segment
					northSouthTrail[northSouthTrailCount].scale.set(1, 1, 1);
					northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ - 5;
					// get the correct current matrix so shadows match exactly
					northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
					northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );
					
					cycleJustTurned = false;
					// get the next segment ready
					spawnTrail(); // spawn another trail segement in the same direction

				}

				trailScale = trailLength / 10;

				northSouthTrail[northSouthTrailCount].scale.set(1, 1, trailScale);
				northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ - (trailLength / 2);
				// update the current active blended trail so its shadow matches exactly
				northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
				// now update the current active trail's shadow
				northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );

			} // end if (cycleDirection == NORTH)
			
			else if (cycleDirection == EAST) {
				
				// record the distance between the cycle and its trail spawn point when it turned or started the match 
				cycleTrailSpawnDistance = Math.abs(cycle.position.x - trailSpawnX) + 0.001;

				if (animatingBlendedTrail) {
					// if the cycle is far enough away from the active trail spawn point, 
					// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
					if (cycleTrailSpawnDistance > 1)
						trailBeginningLength = cycleTrailSpawnDistance - 1;
					else 
						trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet

					// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
					if (trailBeginningLength > 2.1) {
						trailBeginningLength = 2.1;//2.1 instead of 2 to cover up light vertical line segment
						animatingBlendedTrail = false;
					}

					trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
					trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
				}

				// make blended beginning trail closely follow cycle's rear wheel                                                            
				trailBeginning.position.set( cycle.position.x - ( 1 + (trailBeginningLength / 2) ), halfTrailHeight, cycle.position.z );
				// get the correct current matrix so shadows match exactly
				trailBeginning.updateMatrixWorld(true);
				blendedBeginningTrailShadow.update( groundPlane, lightPosition4D );

				// update main trail wall

				// if the cycle is far enough away from the active trail spawn point, 
				// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
				if (cycleTrailSpawnDistance > 3)
					trailLength = cycleTrailSpawnDistance - 3;
				else 
					trailLength = 0.001; // else, the trail doesn't have any noticable length yet

				
				
				
				// when trail wall segment reaches maximum 10 unit length, clamp it.
				// also when this happens, it's time to spawn another trail segment
				if (trailLength > 10) {

					trailLength = 10;
					// cap off current trail segment
					eastWestTrail[eastWestTrailCount].scale.set(1, 1, 1);
					eastWestTrail[eastWestTrailCount].position.x = trailSpawnX + 5;
					// get the correct current matrix so shadows match exactly
					eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
					eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );

					cycleJustTurned = false;
					// get the next segment ready
					spawnTrail(); // spawn another trail segement in the same direction

				}

				
				trailScale = trailLength / 10;
				
				eastWestTrail[eastWestTrailCount].scale.set(trailScale, 1, 1);
				eastWestTrail[eastWestTrailCount].position.x = trailSpawnX + (trailLength / 2);
				// update the current active blended trail so its shadow matches exactly
				eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
				eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );

			} // end else if (cycleDirection == EAST)
			
			else if (cycleDirection == SOUTH) {
				
				// record the distance between the cycle and its trail spawn point when it turned or started the match 
				cycleTrailSpawnDistance = Math.abs(cycle.position.z - trailSpawnZ) + 0.001;

				if (animatingBlendedTrail) {
					// if the cycle is far enough away from the active trail spawn point, 
					// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
					if (cycleTrailSpawnDistance > 1)
						trailBeginningLength = cycleTrailSpawnDistance - 1;
					else 
						trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet

					// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
					if (trailBeginningLength > 2.1) {
						trailBeginningLength = 2.1;//2.1 instead of 2 to cover up light vertical line segment
						animatingBlendedTrail = false;
					}

					trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
					trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
				}

				// make blended beginning trail closely follow cycle's rear wheel                                                         
				trailBeginning.position.set( cycle.position.x, halfTrailHeight, cycle.position.z - 1 - (trailBeginningLength / 2) );
				// get the correct current matrix so shadows match exactly
				trailBeginning.updateMatrixWorld(true);
				blendedBeginningTrailShadow.update( groundPlane, lightPosition4D );

				// update main trail wall

				// if the cycle is far enough away from the active trail spawn point, 
				// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
				if (cycleTrailSpawnDistance > 3)
					trailLength = cycleTrailSpawnDistance - 3;
				else 
					trailLength = 0.001; // else, the trail doesn't have any noticable length yet

				
				
				// when trail wall segment reaches maximum 10 unit length, clamp it.
				// also when this happens, it's time to spawn another trail segment
				if (trailLength > 10) {

					trailLength = 10;
					// cap off current trail segment
					northSouthTrail[northSouthTrailCount].scale.set(1, 1, 1);
					northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ + 5;
					// get the correct current matrix so shadows match exactly
					northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
					northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );
					
					cycleJustTurned = false;
					// get the next segment ready
					spawnTrail(); // spawn another trail segement in the same direction

				}

				trailScale = trailLength / 10;

				northSouthTrail[northSouthTrailCount].scale.set(1, 1, trailScale);
				northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ + (trailLength / 2);
				// update the current active blended trail so its shadow matches exactly
				northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
				// now update the current active trail's shadow
				northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );

			} // end else if (cycleDirection == SOUTH)
			
			else if (cycleDirection == WEST) {
				
				// record the distance between the cycle and its trail spawn point when it turned or started the match 
				cycleTrailSpawnDistance = Math.abs(trailSpawnX - cycle.position.x) + 0.001;

				if (animatingBlendedTrail) {
					// if the cycle is far enough away from the active trail spawn point, 
					// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
					if (cycleTrailSpawnDistance > 1)
						trailBeginningLength = cycleTrailSpawnDistance - 1;
					else 
						trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet

					// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
					if (trailBeginningLength > 2.1) {
						trailBeginningLength = 2.1;//2.1 instead of 2 to cover up light vertical line segment
						animatingBlendedTrail = false;
					}

					trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
					trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
				}

				// make blended beginning trail closely follow cycle's rear wheel                                                            
				trailBeginning.position.set( cycle.position.x + ( 1 + (trailBeginningLength / 2) ), halfTrailHeight, cycle.position.z );
				// get the correct current matrix so shadows match exactly
				trailBeginning.updateMatrixWorld(true);
				blendedBeginningTrailShadow.update( groundPlane, lightPosition4D );

				// update main trail wall

				// if the cycle is far enough away from the active trail spawn point, 
				// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
				if (cycleTrailSpawnDistance > 3)
					trailLength = cycleTrailSpawnDistance - 3;
				else 
					trailLength = 0.001; // else, the trail doesn't have any noticable length yet

				
				
				
				// when trail wall segment reaches maximum 10 unit length, clamp it.
				// also when this happens, it's time to spawn another trail segment
				if (trailLength > 10) {

					trailLength = 10;
					// cap off current trail segment
					eastWestTrail[eastWestTrailCount].scale.set(1, 1, 1);
					eastWestTrail[eastWestTrailCount].position.x = trailSpawnX - 5;
					// get the correct current matrix so shadows match exactly
					eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
					eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );

					cycleJustTurned = false;
					// get the next segment ready
					spawnTrail(); // spawn another trail segement in the same direction

				}

				
				trailScale = trailLength / 10;
				
				eastWestTrail[eastWestTrailCount].scale.set(trailScale, 1, 1);
				eastWestTrail[eastWestTrailCount].position.x = trailSpawnX - (trailLength / 2);
				// update the current active blended trail so its shadow matches exactly
				eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
				eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );

			} // end else if (cycleDirection == WEST)
			
			
			
			// update cycles components
			// spin wheels
			verticalAngle += cycleSpeed * 12 * frameTime;
			if ( verticalAngle > TWO_PI ) {
				verticalAngle -= TWO_PI;
				flipper = !flipper;
			}
			
			cycle.children[2].material.shininess = 100 * flipper;
			cycle.children[2].rotation.z = 0.004 * flipper;
			
			
			// update Camera Object
			// clamp vertical camera rotation so the camera doesn't go through the floor
			if ( Math.abs(cameraControlsPitchObject.rotation.x) < 0.1 || 
			     cameraControlsPitchObject.rotation.x > 0.0 ) {
				//cameraControlsPitchObject.rotation.x = -0.1;
			}
					
			// NOTE: camera.translateZ(cameraDistance) must be called when switching cameras
			
			// follow the player's cycle
			//cameraControlsObject.position.copy(cycle.position);
			
			// for cockpit view only
			//cameraControlsObject.translateY(2.5);
			//cameraControlsObject.translateZ(-1);
			
			if (cycleDirection == NORTH) cycle.position.x = trailSpawnX;
			else if (cycleDirection == SOUTH) cycle.position.x = trailSpawnX;
			else if (cycleDirection == EAST) cycle.position.z = trailSpawnZ;
			else if (cycleDirection == WEST) cycle.position.z = trailSpawnZ;
			
			// update cycle position
			cycle.localToWorld(cycle.position);
			if (!rotateCycleRight && !rotateCycleLeft) {
				cycle.translateOnAxis(cycleHeadingVector, cycleSpeed * frameTime);
			}
			
			
			cycle.worldToLocal(cycle.position);
			if (rotateCycleRight) {
				cycle.rotateOnAxis(upVector, -PI_2);
				rotateCycleRight = false;
			}
			else if (rotateCycleLeft) {
				cycle.rotateOnAxis(upVector, PI_2);
				rotateCycleLeft = false;
			}
			
			// update the cycle's matrix now before shadows areare set (instead of at render time), 
			// so that the shadows line up exactly with the cycle
			cycle.updateMatrixWorld(true);
			
			// update the ShadowMeshes to follow their shadow-casting objects
			cycleShadow[0].update( groundPlane, lightPosition4D );
			cycleShadow[1].update( groundPlane, lightPosition4D );
			cycleShadow[2].update( groundPlane, lightPosition4D );
			cycleShadow[3].update( groundPlane, lightPosition4D );
		
			
			// render the scene with our camera
			renderer.render(scene, camera);
			
			
			
			// real-time debug text output
			//debug1Text.innerHTML = "pitchRotation: " + cameraControlsPitchObject.rotation.x.toFixed(1);
			

		} // end function animate()
		
		
		
		function spawnTrail() {
			
			trailLength = 0.001;
			
			if (cycleDirection == NORTH) {
				
				trailSpawnX = cycle.position.x;
				
				if (cycleJustTurned) {
					trailSpawnX = cycle.position.x;
					trailSpawnZ = cycle.position.z;
				}	
				else {
					trailSpawnX = cycle.position.x;
					trailSpawnZ -= 10;
				}
				
				northSouthTrailCount += 1;
				northSouthTrail[northSouthTrailCount].position.set(trailSpawnX, halfTrailHeight, trailSpawnZ);
				northSouthTrail[northSouthTrailCount].visible = true;
				northSouthTrailShadow[northSouthTrailCount].visible = true;
					
			}
			if (cycleDirection == SOUTH) {
				
				trailSpawnX = cycle.position.x;
				
				if (cycleJustTurned) {
					trailSpawnX = cycle.position.x;
					trailSpawnZ = cycle.position.z;
				}	
				else {
					trailSpawnX = cycle.position.x;
					trailSpawnZ += 10;
				}
				
				northSouthTrailCount += 1;
				northSouthTrail[northSouthTrailCount].position.set(trailSpawnX, halfTrailHeight, trailSpawnZ);
				northSouthTrail[northSouthTrailCount].visible = true;
				northSouthTrailShadow[northSouthTrailCount].visible = true;
					
			}
			if (cycleDirection == EAST) {
				
				if (cycleJustTurned) {
					trailSpawnX = cycle.position.x;
					trailSpawnZ = cycle.position.z;
				}
				else {
					trailSpawnX += 10;
					trailSpawnZ = cycle.position.z;
				}
				
				eastWestTrailCount += 1;
				eastWestTrail[eastWestTrailCount].position.set(trailSpawnX, halfTrailHeight, trailSpawnZ);
				eastWestTrail[eastWestTrailCount].visible = true;
				eastWestTrailShadow[eastWestTrailCount].visible = true;
					
			}
			if (cycleDirection == WEST) {
				
				if (cycleJustTurned) {
					trailSpawnX = cycle.position.x;
					trailSpawnZ = cycle.position.z;
				}
				else {
					trailSpawnX -= 10;
					trailSpawnZ = cycle.position.z;
				}
				
				eastWestTrailCount += 1;
				eastWestTrail[eastWestTrailCount].position.set(trailSpawnX, halfTrailHeight, trailSpawnZ);
				eastWestTrail[eastWestTrailCount].visible = true;
				eastWestTrailShadow[eastWestTrailCount].visible = true;
					
			}
			
			if (cycleJustTurned) {
				animatingBlendedTrail = true;
				cycleJustTurned = false;
			}
			
		} // end function spawnTrail()
		
		
	</script>
</body>

</html>
