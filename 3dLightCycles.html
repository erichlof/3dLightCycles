<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>3dLightCycles</title>
	<style>

		body {
			background-color: rgb(0, 0, 0);
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
		
	</style>
</head>

<body>
	
	<div id="banner" style="position:fixed; left:0; right:0; top:20%; text-align:center; z-index: 10;
                               font-size:40px; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		<!-- Loading... -->
	</div>
	
	<div id="gameover" style="position:fixed; left:0; right:0; top:25%; text-align:center; z-index: 10;
                               font-family:arial; font-type:bold; color:rgb(255,255,255);">
	</div>
	
	<div id="container"></div>

	<div id="debug1" style="position:fixed; left:2%; top:2%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		
	</div>
	
	<div id="help" style="position:fixed; left:2%; bottom:7%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		3dLightCycles
	</div>
	
	<div id="help1" style="position:fixed; left:2%; bottom:4%; font-family:arial; font-size:10px; color:grey;">
		Desktop: Mouse to rotate | Esc: exit
	</div>

	<div id="help2" style="position:fixed; left:2%; bottom:1%; font-family:arial; font-size:10px; color:grey;">
		Mobile: Swipe to rotate
	</div>
	
	<div id="score" style="position:fixed; right:3%; top:1%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		0
	</div>
	
	<div id="sound" style="position:fixed; right:3%; top:14%; font-family:arial; font-type:bold; color:rgb(70,70,70); border:thin solid;">
		Sound: Off
	</div>	

	 <script src="js/three.min.js"></script> 
	<!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script> -->
	<script src="js/ShadowMesh.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
	<script src="js/threex.FirstPersonControls.js"></script>
	<script src="js/virtualButtonJoystick.js"></script>
	<script src="js/threex.GameTimer.js"></script>
	<script src="js/howler.js"></script>
	<script src="js/3dLightCyclesVariables.js"></script>
	
	<script>
		
		
		function initLevel() {
			
			playerAlive = true;
			
			// initial starting position
			cycle.position.set(0, 0, 20);
			
			// initial heading and rotation
			cycleHeadingVector.copy(northVector);
			cycle.rotation.y = north_Y_Rotation;
			
			// for debug flyCam
			cameraControlsObject.position.set(5,10,50);
			
			// look slightly downward
			cameraControlsPitchObject.rotation.x = -0.3;
			
			// for initial 3rd person view, pull the camera back a little
			//camera.translateZ(cameraDistance);
			
			animate();
			
		} // end function initLevel()
		

		function animate() {
			
			// keep looping through animate()
			requestAnimationFrame(animate);
			// store how much time has passed since the last animation frame
			frameTime = clock.getDelta();
			
			// RESPOND TO PLAYER INPUT ///////////////////////////////////////////////////////////////////////////////////////////
			
			// check if joystick Stick is being moved
			if (playerAlive) {
				// if not playing on desktop, get the rotation from the mobile-touch virtual Joystick
				if (!mouseControl) {
					
					cameraControlsYawObject.rotation.y = joystick.previousRotationY - joystick.deltaX() * 0.005;
					cameraControlsPitchObject.rotation.x = joystick.previousRotationX - joystick.deltaY() * 0.005;
					// clamp the camera's vertical movement (around the x-axis) to the 'ceiling' and 'floor',
					// so you can't accidentally flip the camera upside down
					cameraControlsPitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, cameraControlsPitchObject.rotation.x ) );
				
				}

			}
			
			// this gives us a vector in the direction that the camera is pointing,
			// which will be useful for moving the camera 'forward' and shooting projectiles in that direction
			controls.getDirection(cameraRotationVector);
			cameraRotationVector.normalize();
			
			// this following gives us a rotation quaternion (4D vector), which will be useful for 
			// rotating scene objects to match the camera's rotation
			camera.getWorldQuaternion(cameraWorldQuaternion);
			
			// allow flying camera forward
			if ( playerAlive && (joystick.button2Pressed || keyboard.pressed('space')) ) {
				
				cameraControlsObject.localToWorld(cameraControlsObject.position);
				cameraControlsObject.translateOnAxis(cameraRotationVector, 20 * frameTime);
				cameraControlsObject.worldToLocal(cameraControlsObject.position);
				
			}
			
			
			
			
			// GAME LOGIC ////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			if (cycle.position.z < -25) {
				
				cycle.position.z = -25;
				cycleHeadingVector.copy(eastVector);
				cycle.rotation.y = east_Y_Rotation;
				//snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = east_Y_Rotation;
				//joystick.previousRotationY = east_Y_Rotation;
				
			}
			if (cycle.position.x > 25) {
				
				cycle.position.x = 25;
				cycleHeadingVector.copy(southVector);
				cycle.rotation.y = south_Y_Rotation;
				//snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = south_Y_Rotation;
				//joystick.previousRotationY = south_Y_Rotation;
				
			}
			if (cycle.position.z > 25) {
				
				cycle.position.z = 25;
				cycleHeadingVector.copy(westVector);
				cycle.rotation.y = west_Y_Rotation;
				//snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = west_Y_Rotation;
				//joystick.previousRotationY = west_Y_Rotation;
				
			}
			if (cycle.position.x < -25) {
				
				cycle.position.x = -25;
				cycleHeadingVector.copy(northVector);
				cycle.rotation.y = north_Y_Rotation;
				//snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = north_Y_Rotation;
				//joystick.previousRotationY = north_Y_Rotation;
				
			}
			
			
			// UPDATE GAME OBJECTS ///////////////////////////////////////////////////////////////////////////////////////////////
			
			// update Cycles and player camera
			
			// update cycle position
			cycle.localToWorld(cycle.position);
			//cycle.translateOnAxis(cycleHeadingVector, cycleSpeed * frameTime);
			cycle.worldToLocal(cycle.position);
			
			// spin wheels
			verticalAngle += cycleSpeed * 12 * frameTime;
			if ( verticalAngle > TWO_PI ) {
				verticalAngle -= TWO_PI;
				flipper = !flipper;
			}
			
			cycle.children[2].material.shininess = 100 * flipper;
			cycle.children[2].rotation.z = 0.004 * flipper;
			
			// update Camera Object
			// clamp vertical camera rotation so the camera doesn't go through the floor
			if ( Math.abs(cameraControlsPitchObject.rotation.x) < 0.1 || 
			     cameraControlsPitchObject.rotation.x > 0.0 ) {
				//cameraControlsPitchObject.rotation.x = -0.1;
			}
					
			// NOTE: camera.translateZ(cameraDistance) must be called when switching cameras
			
			// follow the player's cycle
			//cameraControlsObject.position.copy(cycle.position);
			
			// for cockpit view only
			//cameraControlsObject.translateY(2.5);
			//cameraControlsObject.translateZ(-1);
			
			// update the cycle's matrix now before shadows are set (instead of at render time), 
			// so that the shadows line up exactly with the cycle
			cycle.updateMatrixWorld(true);
				
			// update the ShadowMeshes to follow their shadow-casting objects
			cycleShadow[0].update( groundPlane, lightPosition4D );
			cycleShadow[1].update( groundPlane, lightPosition4D );
			cycleShadow[2].update( groundPlane, lightPosition4D );
			cycleShadow[3].update( groundPlane, lightPosition4D );
			
			trailShadow[0].update( groundPlane, lightPosition4D );
			trailShadow[1].update( groundPlane, lightPosition4D );
			
			// render the scene with our camera
			renderer.render(scene, camera);
			
			
			
			// real-time debug text output
			//debug1Text.innerHTML = "pitchRotation: " + cameraControlsPitchObject.rotation.x.toFixed(1);
			

		} // end function animate()
		
		
	</script>
</body>

</html>
