<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>3dLightCycles</title>
	<style>

		body {
			background-color: rgb(0, 0, 0);
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
		
		#cameraButton {
			position: absolute;
			left: 1%;
			top: 10%;
		}
		
	</style>
</head>

<body>
	
	<div id="banner" style="position:fixed; left:0; right:0; top:20%; text-align:center; z-index: 1;
                               font-size:40px; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		Loading...
	</div>
	
	<div id="gameover" style="position:fixed; left:0; right:0; top:25%; text-align:center; z-index: 10;
                               font-family:arial; font-type:bold; color:rgb(255,255,255);">
	</div>
	
	<div id="container"></div>
	
	<input id="cameraButton" type="button" value="Switch to Close 3rdPerson view" onclick="cameraButtonHandler()">

	<div id="debug1" style="position:fixed; left:2%; top:2%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		
	</div>
	
	<div id="help" style="position:fixed; left:2%; bottom:7%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		3dLightCycles
	</div>
	
	<div id="help1" style="position:fixed; left:2%; bottom:4%; font-family:arial; font-size:10px; color:grey;">
		Desktop: LMouseButton: Turn L | RMouseButton: Turn R | Mouse: rotate Camera | SPACEBAR: Fly | Esc: exit
	</div>

	<div id="help2" style="position:fixed; left:2%; bottom:1%; font-family:arial; font-size:10px; color:grey;">
		Mobile: PurpleButton: Turn L | OrangeButton: Turn R | Swipe to rotate Camera
	</div>
	
	<div id="score" style="position:fixed; right:3%; top:1%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		0
	</div>
	
	<div id="sound" style="position:fixed; right:3%; top:14%; font-family:arial; font-type:bold; color:rgb(70,70,70); border:thin solid;">
		Sound: Off
	</div>	

	<script src="js/three.min.js"></script> 
	<!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script> -->
	<script src="js/ShadowMesh.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
	<script src="js/threex.FirstPersonControls.js"></script>
	<script src="js/virtualButtonJoystick.js"></script>
	<script src="js/threex.GameTimer.js"></script>
	<script src="js/howler.js"></script>
	<script src="js/3dLightCyclesVariables.js"></script>
	
	<script>
		
		
		function initLevel() {
			
			
			playerAlive = true;
			
			// if on mobile device, unpause the game because there is no ESC key and no mouse capture to do
			if ( !mouseControl )
				gamePaused = false;
			
			// initial starting position
			cycle.position.set(0, 0, 30);
			
			// initial heading and rotation
			cycleDirection = NORTH;
			cycleHeadingVector.copy(northVector);
			
			// trigger a 'dummy' cycleJustTurned event to start new blended trail formation
			cycleJustTurned = true;
			// spawn the cycle's first jet trail
			spawnTrail();
			
			
			// for cockpit View
			if (cameraMode == CockpitCamera_MODE) {
				
				cycle.children[0].visible = false;
				//cycle.children[1].visible = false;
				//cycle.children[2].visible = false;
				cycle.children[3].visible = false;
				
				cameraControlsObject.position.copy(cycle.position);
				cameraControlsObject.position.y += 2;
				// look straight ahead
				cameraControlsPitchObject.rotation.x = 0.0;
				joystick.previousRotationX = 0.0;
			}
			
			// for initial 3rd person view, pull the camera back a little
			//camera.translateZ(cameraDistance);
			
			/*
			// for debug flyCam
			cameraControlsObject.position.set(-5,15,40);
			// look slightly downward
			cameraControlsPitchObject.rotation.x = -0.4;
			joystick.previousRotationX = -0.4;
			*/

			// snap camera to cycle's new heading
			cameraControlsYawObject.rotation.y = north_Y_Rotation;
			joystick.previousRotationY = north_Y_Rotation;
			
			
			if(mouseControl){
				bannerElement.innerHTML = 'Game Paused <br> Click to Play';
			}
			else {
				bannerElement.innerHTML = '';
			}
			
			animate();
			
		} // end function initLevel()
		

		function animate() {
			
			// keep looping through animate()
			requestAnimationFrame(animate);
			// store how much time has passed since the last animation frame
			frameTime = clock.getDelta();
			
			// RESPOND TO PLAYER INPUT //////////////////////////////////////////////////////////////////////////////////////////////
			
			// check if joystick Stick is being moved
			
			// commented out for debug flyCam mode
			if (playerAlive) {
			
				// if not playing on desktop, get the rotation from the mobile-touch virtual Joystick
				if (!mouseControl) {
					
					cameraControlsYawObject.rotation.y = joystick.previousRotationY - joystick.deltaX() * 0.005;
					cameraControlsPitchObject.rotation.x = joystick.previousRotationX - joystick.deltaY() * 0.005;
					// clamp the camera's vertical movement (around the x-axis) to the 'ceiling' and 'floor',
					// so you can't accidentally flip the camera upside down
					cameraControlsPitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, cameraControlsPitchObject.rotation.x ) );
				
				}

			}
			
			// this gives us a vector in the direction that the camera is pointing,
			// which will be useful for moving the camera 'forward' and shooting projectiles in that direction
			controls.getDirection(cameraRotationVector);
			cameraRotationVector.normalize();
			
			// the following gives us a rotation quaternion (4D vector), which will be useful for 
			// rotating scene objects to match the camera's rotation
			camera.getWorldQuaternion(cameraWorldQuaternion);
			/*
			// allow flying camera forward
			if ( keyboard.pressed('space') ) {
				
				cameraControlsObject.localToWorld(cameraControlsObject.position);
				cameraControlsObject.translateOnAxis(cameraRotationVector, 20 * frameTime);
				cameraControlsObject.worldToLocal(cameraControlsObject.position);
				
			}
			*/
			
			//if button1 is NOT pressed, reset it so we can turn again
			if (!joystick.button1Pressed) {
				canTurnRight = true;
			}
			//if button1 IS pressed, check to see if we can shoot
			if (joystick.button1Pressed && playerAlive) {
				if (canTurnRight) {
					rotateCycleRight = true;
					//turn off ability to turn cycle so we don't rapid-fire turn
					canTurnRight = false;
				}
			}
			
			//if button2 is NOT pressed, reset it so we can turn again
			if (!joystick.button2Pressed) {
				canTurnLeft = true;
			}
			//if button2 IS pressed, check to see if we can shoot
			if (joystick.button2Pressed && playerAlive) {
				if (canTurnLeft) {
					rotateCycleLeft = true;
					//turn off ability to turn cycle so we don't rapid-fire turn
					canTurnLeft = false;
				}
			}
			
			
			
			// GAME STATE UPDATE AND LOGIC /////////////////////////////////////////////////////////////////////////////////////////////
			
			// for the game's cutscenes, we remove the camera (child of controls), so we can animate it
			// freely without user interaction. When the cutscene ends, we will re-attach it as a child of controls

			///cameraControlsPitchObject.remove(camera);
			if (playingCrashAnimation) {
				
				crashAnimationTimer.run(frameTime);
				
				explosionTextureSize = (crashAnimationTimer.counter * 3 + 1);
				testTransparency.scale.set(explosionTextureSize, explosionTextureSize, 1);
				testTransparency.position.y = explosionTextureSize / 2;
				testTransparency.material.opacity -= crashAnimationTimer.counter * 0.05;
				
				if (crashAnimationTimer.alarmSounding) {
					
					testTransparency.scale.set(1, 1, 1);
					testTransparency.visible = false;
					testTransparency.material.opacity = 1.0;
					
					playingTrailDisappearAnimation = true;
					playingCrashAnimation = false;
					
					crashAnimationTimer.reset();
					
				}
				
			}
			
			if (playingTrailDisappearAnimation) {
				
				trailDisappearAnimationTimer.run(frameTime);
				
				if (trailDisappearAnimationTimer.alarmSounding) {
					
					for ( var i = 0; i <= eastWestTrailCount; i++ ) {
						eastWestTrail[i].visible = false;
						eastWestTrail[i].matrixAutoUpdate = true;
						eastWestTrailShadow[i].visible = false;
					}
					for ( var i = 0; i <= northSouthTrailCount; i++ ) {
						northSouthTrail[i].visible = false;
						northSouthTrail[i].matrixAutoUpdate = true;
						northSouthTrailShadow[i].visible = false; 
					}
					
					northSouthTrailCount = -1;
					eastWestTrailCount = -1;
					testNSTrailCount = -1;
					testEWTrailCount = -1;
					
					playerAlive = true;
					cycle.visible = true;
					trailBeginning.visible = true;
					blendedBeginningTrailShadow.visible = true;
					
					cycleShadow[0].visible = true;
					cycleShadow[1].visible = true;
					cycleShadow[2].visible = true;
					cycleShadow[3].visible = true;
					
					cycle.worldToLocal(cycle.position);
					if (cycleDirection == WEST) {
						cycle.rotateOnAxis(upVector, -PI_2);
					}
					if (cycleDirection == EAST) {
						cycle.rotateOnAxis(upVector, PI_2);
					}
					if (cycleDirection == SOUTH) {
						cycle.rotateOnAxis(upVector, Math.PI);
					}
					
					// initial starting position
					cycle.localToWorld(cycle.position);
					cycle.position.set(0, 0, 30);
					
					// reset initial heading and rotation
					cycleDirection = NORTH;
					cycleHeadingVector.copy(northVector);

					trailBeginning.rotation.y = north_Y_Rotation;
					// trigger a 'dummy' cycleJustTurned event to start new blended trail formation
					cycleJustTurned = true;
					
					// spawn the cycle's first jet trail
					spawnTrail();

					/*
					// for debug flyCam
					cameraControlsObject.position.set(-5,10,26);

					// look slightly downward
					cameraControlsPitchObject.rotation.x = -0.5;
					joystick.previousRotationX = -0.5;
					*/
					
					// snap camera to cycle's new heading
					cameraControlsYawObject.rotation.y = north_Y_Rotation;
					joystick.previousRotationY = north_Y_Rotation;
					
					playingTrailDisappearAnimation = false;
					trailDisappearAnimationTimer.reset();
					
				}
				
			}
			
			
			
			
			// CHECK FOR AND HANDLE CYCLE TURNING //////////////////////////////////////////////////////////////////////////////////////
			
			if (rotateCycleLeft) {
				if (cycleDirection == NORTH) {
					turningWestFromNorth = true;
				}
				else if (cycleDirection == EAST) {
					turningNorthFromEast = true;
				}
				else if (cycleDirection == SOUTH) {
					turningEastFromSouth = true;
				}
				else if (cycleDirection == WEST) {
					turningSouthFromWest = true;
				}
			}
			if (rotateCycleRight) {
				if (cycleDirection == NORTH) {
					turningEastFromNorth = true;
				}
				else if (cycleDirection == EAST) {
					turningSouthFromEast = true;
				}
				else if (cycleDirection == SOUTH) {
					turningWestFromSouth = true;
				}
				else if (cycleDirection == WEST) {
					turningNorthFromWest = true;
				}
			}
			
			// turning EAST
			if (turningEastFromNorth || turningEastFromSouth) { 
				
				cycleDirection = EAST;
				cycleHeadingVector.copy(eastVector);
				
				trailBeginning.rotation.y = east_Y_Rotation;
				cycleJustTurned = true;
				// make final measurement before we cap off the current wall and turn the cycle
				if (turningEastFromNorth)
					trailLength = Math.abs(trailSpawnZ - cycle.position.z) - 0.02;
				if (turningEastFromSouth)
					trailLength = Math.abs(cycle.position.z - trailSpawnZ) - 0.02;
				trailScale = trailLength / 10;
				
				northSouthTrail[northSouthTrailCount].scale.set(1, 1, trailScale);
				if (turningEastFromNorth)
					northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ - (trailLength / 2);
				if (turningEastFromSouth)
					northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ + (trailLength / 2);
				
				turningEastFromNorth = false;
				turningEastFromSouth = false;
				
				// get the correct current matrix so shadows match exactly
				northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
				northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );
				
				
				spawnTrail();
				
				// snap camera to cycle's new heading
				cameraControlsYawObject.rotation.y = east_Y_Rotation;
				joystick.previousRotationY = east_Y_Rotation;
				
			}
			
			// turning SOUTH
			if (turningSouthFromEast || turningSouthFromWest) {
				
				cycleDirection = SOUTH;
				cycleHeadingVector.copy(southVector);
				
				trailBeginning.rotation.y = south_Y_Rotation;
				cycleJustTurned = true;
				// make final measurement before we cap off the current wall and turn the cycle
				if (turningSouthFromEast)
					trailLength = Math.abs(cycle.position.x - trailSpawnX) - 0.02;
				if (turningSouthFromWest)
					trailLength = Math.abs(trailSpawnX - cycle.position.x) - 0.02;
				trailScale = trailLength / 10;
				
				eastWestTrail[eastWestTrailCount].scale.set(trailScale, 1, 1);
				if (turningSouthFromEast)
					eastWestTrail[eastWestTrailCount].position.x = trailSpawnX + (trailLength / 2);
				if (turningSouthFromWest)
					eastWestTrail[eastWestTrailCount].position.x = trailSpawnX - (trailLength / 2);
				
				turningSouthFromEast = false;
				turningSouthFromWest = false;
				
				
				eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
				eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );
				
				
				spawnTrail();
				
				// snap camera to cycle's new heading
				cameraControlsYawObject.rotation.y = south_Y_Rotation;
				joystick.previousRotationY = south_Y_Rotation;
				
			}
			
			// turning WEST
			if (turningWestFromNorth || turningWestFromSouth) {
				
				cycleDirection = WEST;
				cycleHeadingVector.copy(westVector);
				
				trailBeginning.rotation.y = west_Y_Rotation;
				cycleJustTurned = true;
				// make final measurement before we cap off the current wall and turn the cycle
				if (turningWestFromSouth)
					trailLength = Math.abs(cycle.position.z - trailSpawnZ) - 0.02;
				if (turningWestFromNorth)
					trailLength = Math.abs(trailSpawnZ - cycle.position.z) - 0.02;
				trailScale = trailLength / 10;
				
				northSouthTrail[northSouthTrailCount].scale.set(1, 1, trailScale);
				if (turningWestFromSouth)
					northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ + (trailLength / 2);
				if (turningWestFromNorth)
					northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ - (trailLength / 2);
				
				turningWestFromNorth = false;
				turningWestFromSouth = false;
				
				
				northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
				northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );
				
				
				spawnTrail();
				
				// snap camera to cycle's new heading
				cameraControlsYawObject.rotation.y = west_Y_Rotation;
				joystick.previousRotationY = west_Y_Rotation;
				
			}
			
			// turning NORTH
			if (turningNorthFromEast || turningNorthFromWest) {
				
				cycleDirection = NORTH;
				cycleHeadingVector.copy(northVector);
			
				trailBeginning.rotation.y = north_Y_Rotation;
				cycleJustTurned = true;
				// make final measurement before we cap off the current wall and turn the cycle
				if (turningNorthFromWest)
					trailLength = Math.abs(trailSpawnX - cycle.position.x) - 0.02;
				if (turningNorthFromEast)
					trailLength = Math.abs(cycle.position.x - trailSpawnX) - 0.02;
				trailScale = trailLength / 10;
				
				eastWestTrail[eastWestTrailCount].scale.set(trailScale, 1, 1);
				if (turningNorthFromWest)
					eastWestTrail[eastWestTrailCount].position.x = trailSpawnX - (trailLength / 2);
				if (turningNorthFromEast)
					eastWestTrail[eastWestTrailCount].position.x = trailSpawnX + (trailLength / 2);
				
				turningNorthFromEast = false;
				turningNorthFromWest = false;
				
				
				eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
				eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );
				
				
				spawnTrail();
				
				// snap camera to cycle's new heading
				cameraControlsYawObject.rotation.y = north_Y_Rotation;
				joystick.previousRotationY = north_Y_Rotation;
				
			}
			
			
			// UPDATE CYCLE ORIENTATION AND POSITION  ////////////////////////////////////////////////////////////////////////////
			
			if (playerAlive && !gamePaused) {
				
				
				if (cycleDirection == NORTH) cycle.position.x = trailSpawnX;
				else if (cycleDirection == SOUTH) cycle.position.x = trailSpawnX;
				else if (cycleDirection == EAST) cycle.position.z = trailSpawnZ;
				else if (cycleDirection == WEST) cycle.position.z = trailSpawnZ;

				// update cycle position
				cycle.localToWorld(cycle.position);
				if ( !rotateCycleRight && !rotateCycleLeft ) {
					cycle.translateOnAxis(cycleHeadingVector, cycleSpeed * frameTime);
				}


				cycle.worldToLocal(cycle.position);
				if (rotateCycleRight) {
					cycle.rotateOnAxis(upVector, -PI_2);
					rotateCycleRight = false;
				}
				else if (rotateCycleLeft) {
					cycle.rotateOnAxis(upVector, PI_2);
					rotateCycleLeft = false;
				}


				// update the cycle's matrix now before shadows areare set (instead of at render time), 
				// so that the shadows line up exactly with the cycle
				cycle.updateMatrixWorld(true);

				// update the ShadowMeshes to follow their shadow-casting objects
				cycleShadow[0].update( groundPlane, lightPosition4D );
				cycleShadow[1].update( groundPlane, lightPosition4D );
				cycleShadow[2].update( groundPlane, lightPosition4D );
				cycleShadow[3].update( groundPlane, lightPosition4D );
			
			


				// UPDATE TRAILS //////////////////////////////////////////////////////////////////////////////////////////////////////

				// based on cycleDirection, update the current trail

				if (cycleDirection == NORTH) {

					// record the distance between the cycle and its trail spawn point when it turned or started the match 
					cycleTrailSpawnDistance = Math.abs(trailSpawnZ - cycle.position.z) + 0.001;

					if (animatingBlendedTrail) {
						// if the cycle is far enough away from the active trail spawn point, 
						// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
						if (cycleTrailSpawnDistance > 1)
							trailBeginningLength = cycleTrailSpawnDistance - 1;
						else 
							trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet

						// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
						if (trailBeginningLength > 2.1) {
							trailBeginningLength = 2.1;//2.1 instead of 2 to cover up light vertical line segment
							animatingBlendedTrail = false;
						}

						trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
						trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
					}

					// make blended beginning trail closely follow cycle's rear wheel                                                         
					trailBeginning.position.set( cycle.position.x, halfTrailHeight, cycle.position.z + 1 + (trailBeginningLength / 2) );
					// get the correct current matrix so shadows match exactly
					trailBeginning.updateMatrixWorld(true);
					blendedBeginningTrailShadow.update( groundPlane, lightPosition4D );

					// update main trail wall

					// if the cycle is far enough away from the active trail spawn point, 
					// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
					if (cycleTrailSpawnDistance > 3)
						trailLength = cycleTrailSpawnDistance - 3;
					else 
						trailLength = 0.001; // else, the trail doesn't have any noticable length yet



					// when trail wall segment reaches maximum 10 unit length, clamp it.
					// also when this happens, it's time to spawn another trail segment
					if (trailLength > 10) {

						trailLength = 10;
						// cap off current trail segment
						northSouthTrail[northSouthTrailCount].scale.set(1, 1, 1);
						northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ - 5;
						// get the correct current matrix so shadows match exactly
						northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
						northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );

						cycleJustTurned = false;
						// get the next segment ready
						spawnTrail(); // spawn another trail segement in the same direction

					}

					trailScale = trailLength / 10;

					northSouthTrail[northSouthTrailCount].scale.set(1, 1, trailScale);
					northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ - (trailLength / 2);
					// update the current active blended trail so its shadow matches exactly
					northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
					// now update the current active trail's shadow
					northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );

					// update the active blended trail's collision geometry
					test_NS_trailEndZ[testNSTrailCount] = cycle.position.z;

				} // end if (cycleDirection == NORTH)

				else if (cycleDirection == EAST) {

					// record the distance between the cycle and its trail spawn point when it turned or started the match 
					cycleTrailSpawnDistance = Math.abs(cycle.position.x - trailSpawnX) + 0.001;

					if (animatingBlendedTrail) {
						// if the cycle is far enough away from the active trail spawn point, 
						// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
						if (cycleTrailSpawnDistance > 1)
							trailBeginningLength = cycleTrailSpawnDistance - 1;
						else 
							trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet

						// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
						if (trailBeginningLength > 2.1) {
							trailBeginningLength = 2.1;//2.1 instead of 2 to cover up light vertical line segment
							animatingBlendedTrail = false;
						}

						trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
						trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
					}

					// make blended beginning trail closely follow cycle's rear wheel                                                            
					trailBeginning.position.set( cycle.position.x - ( 1 + (trailBeginningLength / 2) ), halfTrailHeight, cycle.position.z );
					// get the correct current matrix so shadows match exactly
					trailBeginning.updateMatrixWorld(true);
					blendedBeginningTrailShadow.update( groundPlane, lightPosition4D );

					// update main trail wall

					// if the cycle is far enough away from the active trail spawn point, 
					// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
					if (cycleTrailSpawnDistance > 3)
						trailLength = cycleTrailSpawnDistance - 3;
					else 
						trailLength = 0.001; // else, the trail doesn't have any noticable length yet




					// when trail wall segment reaches maximum 10 unit length, clamp it.
					// also when this happens, it's time to spawn another trail segment
					if (trailLength > 10) {

						trailLength = 10;
						// cap off current trail segment
						eastWestTrail[eastWestTrailCount].scale.set(1, 1, 1);
						eastWestTrail[eastWestTrailCount].position.x = trailSpawnX + 5;
						// get the correct current matrix so shadows match exactly
						eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
						eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );

						cycleJustTurned = false;
						// get the next segment ready
						spawnTrail(); // spawn another trail segement in the same direction

					}


					trailScale = trailLength / 10;

					eastWestTrail[eastWestTrailCount].scale.set(trailScale, 1, 1);
					eastWestTrail[eastWestTrailCount].position.x = trailSpawnX + (trailLength / 2);
					// update the current active blended trail so its shadow matches exactly
					eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
					eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );

					test_EW_trailEndX[testEWTrailCount] = cycle.position.x;

				} // end else if (cycleDirection == EAST)

				else if (cycleDirection == SOUTH) {

					// record the distance between the cycle and its trail spawn point when it turned or started the match 
					cycleTrailSpawnDistance = Math.abs(cycle.position.z - trailSpawnZ) + 0.001;

					if (animatingBlendedTrail) {
						// if the cycle is far enough away from the active trail spawn point, 
						// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
						if (cycleTrailSpawnDistance > 1)
							trailBeginningLength = cycleTrailSpawnDistance - 1;
						else 
							trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet

						// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
						if (trailBeginningLength > 2.1) {
							trailBeginningLength = 2.1;//2.1 instead of 2 to cover up light vertical line segment
							animatingBlendedTrail = false;
						}

						trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
						trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
					}

					// make blended beginning trail closely follow cycle's rear wheel                                                         
					trailBeginning.position.set( cycle.position.x, halfTrailHeight, cycle.position.z - 1 - (trailBeginningLength / 2) );
					// get the correct current matrix so shadows match exactly
					trailBeginning.updateMatrixWorld(true);
					blendedBeginningTrailShadow.update( groundPlane, lightPosition4D );

					// update main trail wall

					// if the cycle is far enough away from the active trail spawn point, 
					// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
					if (cycleTrailSpawnDistance > 3)
						trailLength = cycleTrailSpawnDistance - 3;
					else 
						trailLength = 0.001; // else, the trail doesn't have any noticable length yet



					// when trail wall segment reaches maximum 10 unit length, clamp it.
					// also when this happens, it's time to spawn another trail segment
					if (trailLength > 10) {

						trailLength = 10;
						// cap off current trail segment
						northSouthTrail[northSouthTrailCount].scale.set(1, 1, 1);
						northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ + 5;
						// get the correct current matrix so shadows match exactly
						northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
						northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );

						cycleJustTurned = false;
						// get the next segment ready
						spawnTrail(); // spawn another trail segement in the same direction

					}

					trailScale = trailLength / 10;

					northSouthTrail[northSouthTrailCount].scale.set(1, 1, trailScale);
					northSouthTrail[northSouthTrailCount].position.z = trailSpawnZ + (trailLength / 2);
					// update the current active blended trail so its shadow matches exactly
					northSouthTrail[northSouthTrailCount].updateMatrixWorld(true);
					// now update the current active trail's shadow
					northSouthTrailShadow[northSouthTrailCount].update( groundPlane, lightPosition4D );

					test_NS_trailEndZ[testNSTrailCount] = cycle.position.z;

				} // end else if (cycleDirection == SOUTH)

				else if (cycleDirection == WEST) {

					// record the distance between the cycle and its trail spawn point when it turned or started the match 
					cycleTrailSpawnDistance = Math.abs(trailSpawnX - cycle.position.x) + 0.001;

					if (animatingBlendedTrail) {
						// if the cycle is far enough away from the active trail spawn point, 
						// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
						if (cycleTrailSpawnDistance > 1)
							trailBeginningLength = cycleTrailSpawnDistance - 1;
						else 
							trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet

						// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
						if (trailBeginningLength > 2.1) {
							trailBeginningLength = 2.1;//2.1 instead of 2 to cover up light vertical line segment
							animatingBlendedTrail = false;
						}

						trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
						trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
					}

					// make blended beginning trail closely follow cycle's rear wheel                                                            
					trailBeginning.position.set( cycle.position.x + ( 1 + (trailBeginningLength / 2) ), halfTrailHeight, cycle.position.z );
					// get the correct current matrix so shadows match exactly
					trailBeginning.updateMatrixWorld(true);
					blendedBeginningTrailShadow.update( groundPlane, lightPosition4D );

					// update main trail wall

					// if the cycle is far enough away from the active trail spawn point, 
					// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
					if (cycleTrailSpawnDistance > 3)
						trailLength = cycleTrailSpawnDistance - 3;
					else 
						trailLength = 0.001; // else, the trail doesn't have any noticable length yet




					// when trail wall segment reaches maximum 10 unit length, clamp it.
					// also when this happens, it's time to spawn another trail segment
					if (trailLength > 10) {

						trailLength = 10;
						// cap off current trail segment
						eastWestTrail[eastWestTrailCount].scale.set(1, 1, 1);
						eastWestTrail[eastWestTrailCount].position.x = trailSpawnX - 5;
						// get the correct current matrix so shadows match exactly
						eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
						eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );

						cycleJustTurned = false;
						// get the next segment ready
						spawnTrail(); // spawn another trail segement in the same direction

					}


					trailScale = trailLength / 10;

					eastWestTrail[eastWestTrailCount].scale.set(trailScale, 1, 1);
					eastWestTrail[eastWestTrailCount].position.x = trailSpawnX - (trailLength / 2);
					// update the current active blended trail so its shadow matches exactly
					eastWestTrail[eastWestTrailCount].updateMatrixWorld(true);
					eastWestTrailShadow[eastWestTrailCount].update( groundPlane, lightPosition4D );

					test_EW_trailEndX[testEWTrailCount] = cycle.position.x;

				} // end else if (cycleDirection == WEST)


				
				
				// CHECK FOR COLLISIONS WITH TRAILS AND ARENA WALLS //////////////////////////////////////////////////////////////////

				// set up a reference to cycle's position for faster loop lookup
				cyclePositionX = cycle.position.x;
				cyclePositionZ = cycle.position.z;


				if (cycleDirection == NORTH) {

					for ( var i = 0; i < testEWTrailCount; i++ ) {

						if ( cyclePositionZ < test_EW_trailZ[i] && test_NS_currentTrailStartZ > test_EW_trailZ[i] ) {

							if ( cyclePositionX > test_EW_trailStartX[i] && cyclePositionX < test_EW_trailEndX[i] ) {
								cycle.position.z = test_EW_trailZ[i] + 1;
								cycleCrash();
							}
							if ( cyclePositionX < test_EW_trailStartX[i] && cyclePositionX > test_EW_trailEndX[i] ) {
								cycle.position.z = test_EW_trailZ[i] + 1;
								cycleCrash();
							}
						}

					}

				}
				else if (cycleDirection == SOUTH) {

					for ( var i = 0; i < testEWTrailCount; i++ ) {

						if ( cyclePositionZ > test_EW_trailZ[i] && test_NS_currentTrailStartZ < test_EW_trailZ[i] ) {

							if ( cyclePositionX > test_EW_trailStartX[i] && cyclePositionX < test_EW_trailEndX[i] ) {
								cycle.position.z = test_EW_trailZ[i] - 1;
								cycleCrash();
							}
							if ( cyclePositionX < test_EW_trailStartX[i] && cyclePositionX > test_EW_trailEndX[i] ) {
								cycle.position.z = test_EW_trailZ[i] - 1;
								cycleCrash();
							}
						}

					}

				}
				else if (cycleDirection == EAST) {
					
					for ( var i = 0; i < testNSTrailCount; i++ ) {

						if ( cyclePositionX > test_NS_trailX[i] && test_EW_currentTrailStartX < test_NS_trailX[i] ) {

							if ( cyclePositionZ > test_NS_trailStartZ[i] && cyclePositionZ < test_NS_trailEndZ[i] ) {
								cycle.position.x = test_NS_trailX[i] - 1;
								cycleCrash();
							}
							if ( cyclePositionZ < test_NS_trailStartZ[i] && cyclePositionZ > test_NS_trailEndZ[i] ) {
								cycle.position.x = test_NS_trailX[i] - 1;
								cycleCrash();
							}
						}

					}

				}
				else if (cycleDirection == WEST) {
					
					for ( var i = 0; i < testNSTrailCount; i++ ) {

						if ( cyclePositionX < test_NS_trailX[i] && test_EW_currentTrailStartX > test_NS_trailX[i] ) {

							if ( cyclePositionZ > test_NS_trailStartZ[i] && cyclePositionZ < test_NS_trailEndZ[i] ) {
								cycle.position.x = test_NS_trailX[i] + 1;
								cycleCrash();
							}
							if ( cyclePositionZ < test_NS_trailStartZ[i] && cyclePositionZ > test_NS_trailEndZ[i] ) {
								cycle.position.x = test_NS_trailX[i] + 1;
								cycleCrash();
							}
						}

					}

				}
				
				if (cyclePositionX > arenaRadius) {
					cycle.position.x = arenaRadius - 1;
					cycleCrash();
				}
				else if (cyclePositionX < -arenaRadius) {
					cycle.position.x = -arenaRadius + 1;
					cycleCrash();
				}
				else if (cyclePositionZ > arenaRadius) {
					cycle.position.z = arenaRadius - 1;
					cycleCrash();
				}
				else if (cyclePositionZ < -arenaRadius) {
					cycle.position.z = -arenaRadius + 1;
					cycleCrash();
				}
				// update cycles components
				// spin wheels
				verticalAngle += cycleSpeed * 12 * frameTime;
				if ( verticalAngle > TWO_PI ) {
					verticalAngle -= TWO_PI;
					flipper = !flipper;
				}

				cycle.children[2].material.shininess = 100 * flipper;
				cycle.children[2].rotation.z = 0.004 * flipper;
				
			
			} // end if (playerAlive)
			
			
			
			// update Camera Object
			
			
			// NOTE: camera.translateZ(cameraDistance) must be called when switching cameras
			
			// follow the player's cycle
			cameraControlsObject.position.copy(cycle.position);
			if (cameraMode == CockpitCamera_MODE) {
				cameraControlsObject.position.y += 1;
			} // clamp vertical camera rotation so the camera doesn't go through the floor
			else if ( Math.abs(cameraControlsPitchObject.rotation.x) < 0.01 || 
			     cameraControlsPitchObject.rotation.x > 0.0 ) {
				
				cameraControlsPitchObject.rotation.x = -0.01;
			}
		
			// render the scene with our camera
			renderer.render(scene, camera);
			
			
			/*
			// real-time debug text output
			debug1Element.innerHTML = "cyclePositionX: " + cyclePositionX.toFixed(1) + "<br>" + 
					             "cyclePositionZ: " + cyclePositionZ.toFixed(1);
			*/		       
			

		} // end function animate()
		
		
		
		function spawnTrail() {
			
			trailLength = 0.001;
			
			if (cycleDirection == NORTH) {
				
				if (cycleJustTurned) {
					
					trailSpawnX = cycle.position.x;
					trailSpawnZ = cycle.position.z;
					
					testNSTrailCount += 1;
					test_NS_trailX[testNSTrailCount] = trailSpawnX;
					test_NS_trailStartZ[testNSTrailCount] = trailSpawnZ;
				     // test_NS_trailEndZ will be continually updated from cycle's z position
					
					// record the current blended trail starting point for later checking
					test_NS_currentTrailStartZ = trailSpawnZ;
					// cap off the current collision test trail in the previous direction
					if (testEWTrailCount > -1) {
						test_EW_trailEndX[testEWTrailCount] = trailSpawnX;
					}
					
				}	
				else { // spawn another trail wall segment in the same direction
					trailSpawnX = cycle.position.x;
					trailSpawnZ -= 10;
				}
				
				// disable matrix updating for the previous trail segment / shadow, in order to 
				// optimize game loop time when there are lots of trail segments
				if (northSouthTrailCount > -1) {
					northSouthTrail[northSouthTrailCount].matrixAutoUpdate = false;
				}
				
				
				northSouthTrailCount += 1;
				northSouthTrail[northSouthTrailCount].position.set(trailSpawnX, halfTrailHeight, trailSpawnZ);
				northSouthTrail[northSouthTrailCount].visible = true;
				northSouthTrailShadow[northSouthTrailCount].visible = true;
					
			}
			if (cycleDirection == SOUTH) {
				
				if (cycleJustTurned) {
					
					trailSpawnX = cycle.position.x;
					trailSpawnZ = cycle.position.z;
					
					testNSTrailCount += 1;
					test_NS_trailX[testNSTrailCount] = trailSpawnX;
					test_NS_trailStartZ[testNSTrailCount] = trailSpawnZ;
				     // test_NS_trailEndZ will be continually updated from cycle's z position
					
					// record the current blended trail starting point for later checking
					test_NS_currentTrailStartZ = trailSpawnZ;
					// cap off the current collision test trail in the previous direction
					if (testEWTrailCount > -1) {
						test_EW_trailEndX[testEWTrailCount] = trailSpawnX;
					}
					
				}	
				else {
					trailSpawnX = cycle.position.x;
					trailSpawnZ += 10;
				}
				
				if (northSouthTrailCount > -1) {
					northSouthTrail[northSouthTrailCount].matrixAutoUpdate = false;
				}
				
				northSouthTrailCount += 1;
				northSouthTrail[northSouthTrailCount].position.set(trailSpawnX, halfTrailHeight, trailSpawnZ);
				northSouthTrail[northSouthTrailCount].visible = true;
				northSouthTrailShadow[northSouthTrailCount].visible = true;
					
			}
			if (cycleDirection == EAST) {
				
				if (cycleJustTurned) {
					trailSpawnX = cycle.position.x;
					trailSpawnZ = cycle.position.z;
					
					testEWTrailCount += 1;
					test_EW_trailStartX[testEWTrailCount] = trailSpawnX;
					test_EW_trailZ[testEWTrailCount] = trailSpawnZ;
					
					// record the current blended trail starting point for later checking
					test_EW_currentTrailStartX = trailSpawnX;
					
					if (testNSTrailCount > -1) {
						test_NS_trailEndZ[testNSTrailCount] = trailSpawnZ;
					}
				}
				else {
					trailSpawnX += 10;
					trailSpawnZ = cycle.position.z;
				}
				
				if (eastWestTrailCount > -1) {
					eastWestTrail[eastWestTrailCount].matrixAutoUpdate = false;
				}
				
				eastWestTrailCount += 1;
				eastWestTrail[eastWestTrailCount].position.set(trailSpawnX, halfTrailHeight, trailSpawnZ);
				eastWestTrail[eastWestTrailCount].visible = true;
				eastWestTrailShadow[eastWestTrailCount].visible = true;
					
			}
			if (cycleDirection == WEST) {
				
				if (cycleJustTurned) {
					trailSpawnX = cycle.position.x;
					trailSpawnZ = cycle.position.z;
					
					testEWTrailCount += 1;
					test_EW_trailStartX[testEWTrailCount] = trailSpawnX;
					test_EW_trailZ[testEWTrailCount] = trailSpawnZ;
					
					// record the current blended trail starting point for later checking
					test_EW_currentTrailStartX = trailSpawnX;
					
					if (testNSTrailCount > -1) {
						test_NS_trailEndZ[testNSTrailCount] = trailSpawnZ;
					}
				}
				else {
					trailSpawnX -= 10;
					trailSpawnZ = cycle.position.z;
				}
				
				if (eastWestTrailCount > -1) {
					eastWestTrail[eastWestTrailCount].matrixAutoUpdate = false;
				}
				
				eastWestTrailCount += 1;
				eastWestTrail[eastWestTrailCount].position.set(trailSpawnX, halfTrailHeight, trailSpawnZ);
				eastWestTrail[eastWestTrailCount].visible = true;
				eastWestTrailShadow[eastWestTrailCount].visible = true;
					
			}
			
			if (cycleJustTurned) {
				animatingBlendedTrail = true;
				cycleJustTurned = false;
			}
			
		} // end function spawnTrail()
		
		function cycleCrash () {
			
			playerAlive = false;
			cycle.visible = false;
			trailBeginning.visible = false;
			blendedBeginningTrailShadow.visible = false;
			
			testTransparency.visible = true;
			
			cycleShadow[0].visible = false;
			cycleShadow[1].visible = false;
			cycleShadow[2].visible = false;
			cycleShadow[3].visible = false;
			
			testTransparency.position.copy(cycle.position);
			testTransparency.rotation.copy(cycle.rotation);
			
			playingCrashAnimation = true;
			
		}
		
		function cameraButtonHandler() {
			
			cameraMode += 1;
			if (cameraMode > 3) cameraMode = 0;
			
			switch (cameraMode) {
					
				case CockpitCamera_MODE:
					
					cameraDistance = 0;
					camera.position.set(0,0,0);
					
					cycle.children[0].visible = false;
					//cycle.children[1].visible = false;
					//cycle.children[2].visible = false;
					cycle.children[3].visible = false;
					
					document.getElementById("cameraButton").value = "Switch to Close 3rdPerson view";
					
					break;
					
				case Close_3rdPersonCamera_MODE:
					
					cameraDistance = 10;
					camera.translateZ(cameraDistance);
					
					cycle.children[0].visible = true;
					cycle.children[1].visible = true;
					cycle.children[2].visible = true;
					cycle.children[3].visible = true;
					
					document.getElementById("cameraButton").value = "Switch to Far 3rdPerson view";
					
					break;
					
				case Remote_3rdPersonCamera_MODE:
					
					cameraDistance = 20;
					camera.translateZ(cameraDistance);
					
					cycle.children[0].visible = true;
					cycle.children[1].visible = true;
					cycle.children[2].visible = true;
					cycle.children[3].visible = true;
					
					document.getElementById("cameraButton").value = "Switch to SkyCamera view";
					
					break;
					
				case SkyCamera_MODE:
					
					cameraDistance = 40;
					camera.translateZ(cameraDistance);
					
					cycle.children[0].visible = true;
					cycle.children[1].visible = true;
					cycle.children[2].visible = true;
					cycle.children[3].visible = true;
					
					document.getElementById("cameraButton").value = "Switch to Cockpit view";
					
					break;
					
				default:
					document.getElementById("cameraButton").value = "Switch to Close 3rdPerson view";
					
			}
				
			
		}
		
		
	</script>
</body>

</html>
