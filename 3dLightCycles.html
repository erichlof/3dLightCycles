<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>3dLightCycles</title>
	<style>

		body {
			background-color: rgb(0, 0, 0);
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
		
	</style>
</head>

<body>
	
	<div id="banner" style="position:fixed; left:0; right:0; top:20%; text-align:center; z-index: 10;
                               font-size:40px; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		<!-- Loading... -->
	</div>
	
	<div id="gameover" style="position:fixed; left:0; right:0; top:25%; text-align:center; z-index: 10;
                               font-family:arial; font-type:bold; color:rgb(255,255,255);">
	</div>
	
	<div id="container"></div>

	<div id="debug1" style="position:fixed; left:2%; top:2%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		
	</div>
	
	<div id="help" style="position:fixed; left:2%; bottom:7%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		3dLightCycles
	</div>
	
	<div id="help1" style="position:fixed; left:2%; bottom:4%; font-family:arial; font-size:10px; color:grey;">
		Desktop: Mouse to rotate | Esc: exit
	</div>

	<div id="help2" style="position:fixed; left:2%; bottom:1%; font-family:arial; font-size:10px; color:grey;">
		Mobile: Swipe to rotate
	</div>
	
	<div id="score" style="position:fixed; right:3%; top:1%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		0
	</div>
	
	<div id="sound" style="position:fixed; right:3%; top:14%; font-family:arial; font-type:bold; color:rgb(70,70,70); border:thin solid;">
		Sound: Off
	</div>	

	 <script src="js/three.min.js"></script> 
	<!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script> -->
	<script src="js/ShadowMesh.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
	<script src="js/threex.FirstPersonControls.js"></script>
	<script src="js/virtualButtonJoystick.js"></script>
	<script src="js/threex.GameTimer.js"></script>
	<script src="js/howler.js"></script>
	<script src="js/3dLightCyclesVariables.js"></script>
	
	<script>
		
		
		function initLevel() {
			
			playerAlive = true;
			
			// initial starting position
			cycle.position.set(0, 0, 35);
			
			// initial heading and rotation
			cycleDirection = NORTH;
			cycleHeadingVector.copy(northVector);
			cycle.rotation.y = north_Y_Rotation;
			
			// for debug flyCam
			cameraControlsObject.position.set(-5,5,26);
			
			// for debugging jet trail, look east
			cameraControlsYawObject.rotation.y = -1.6;
			joystick.previousRotationY = -1.6;
			// look slightly downward
			cameraControlsPitchObject.rotation.x = -0.5;
			joystick.previousRotationX = -0.5;
			
			// for initial 3rd person view, pull the camera back a little
			//camera.translateZ(cameraDistance);
			
			animate();
			
		} // end function initLevel()
		

		function animate() {
			
			// keep looping through animate()
			requestAnimationFrame(animate);
			// store how much time has passed since the last animation frame
			frameTime = clock.getDelta();
			
			// RESPOND TO PLAYER INPUT ///////////////////////////////////////////////////////////////////////////////////////////
			
			// check if joystick Stick is being moved
			if (playerAlive) {
				// if not playing on desktop, get the rotation from the mobile-touch virtual Joystick
				if (!mouseControl) {
					
					cameraControlsYawObject.rotation.y = joystick.previousRotationY - joystick.deltaX() * 0.005;
					cameraControlsPitchObject.rotation.x = joystick.previousRotationX - joystick.deltaY() * 0.005;
					// clamp the camera's vertical movement (around the x-axis) to the 'ceiling' and 'floor',
					// so you can't accidentally flip the camera upside down
					cameraControlsPitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, cameraControlsPitchObject.rotation.x ) );
				
				}

			}
			
			// this gives us a vector in the direction that the camera is pointing,
			// which will be useful for moving the camera 'forward' and shooting projectiles in that direction
			controls.getDirection(cameraRotationVector);
			cameraRotationVector.normalize();
			
			// this following gives us a rotation quaternion (4D vector), which will be useful for 
			// rotating scene objects to match the camera's rotation
			camera.getWorldQuaternion(cameraWorldQuaternion);
			
			// allow flying camera forward
			if ( playerAlive && (joystick.button2Pressed || keyboard.pressed('space')) ) {
				
				cameraControlsObject.localToWorld(cameraControlsObject.position);
				cameraControlsObject.translateOnAxis(cameraRotationVector, 20 * frameTime);
				cameraControlsObject.worldToLocal(cameraControlsObject.position);
				
			}
			
			
			
			
			// GAME LOGIC ////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			// update cycle position
			cycle.localToWorld(cycle.position);
			cycle.translateOnAxis(cycleHeadingVector, cycleSpeed * frameTime);
			cycle.worldToLocal(cycle.position);
			
			//warp for debugging trails
			                   // -35
			if (cycle.position.z < 20) { 
				
				//warp for debugging trails
				cycle.position.z = 35;
				//end debug warp
				
				//cycle.position.z = -35;
				//cycleHeadingVector.copy(eastVector);
				//cycle.rotation.y = east_Y_Rotation;
				
				//snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = east_Y_Rotation;
				//joystick.previousRotationY = east_Y_Rotation;
				
			}
			if (cycle.position.x > 35) {
				
				cycle.position.x = 35;
				cycleHeadingVector.copy(southVector);
				cycle.rotation.y = south_Y_Rotation;
				//snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = south_Y_Rotation;
				//joystick.previousRotationY = south_Y_Rotation;
				
			}
			if (cycle.position.z > 35) {
				
				cycle.position.z = 35;
				cycleHeadingVector.copy(westVector);
				cycle.rotation.y = west_Y_Rotation;
				//snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = west_Y_Rotation;
				//joystick.previousRotationY = west_Y_Rotation;
				
			}
			if (cycle.position.x < -35) {
				
				cycle.position.x = -35;
				cycleHeadingVector.copy(northVector);
				cycle.rotation.y = north_Y_Rotation;
				//snap camera to cycle's new heading
				//cameraControlsYawObject.rotation.y = north_Y_Rotation;
				//joystick.previousRotationY = north_Y_Rotation;
				
			}
			
			
			// UPDATE GAME OBJECTS ///////////////////////////////////////////////////////////////////////////////////////////////
			
			
			/*
			testAngle += 0.1 * frameTime;
			if ( testAngle > PI_2 ) {
				testAngle = 0;
			}
			*/
			//trailBeginningLength = Math.abs( Math.sin(testAngle) ) * 4 + 0.001;
			//trailLength = Math.abs( Math.sin(testAngle) ) * 20 + 0.001;
			
			trailSpawnZ = 35;
			// record the distance between the cycle and its trail spawn point when it turned or started the match 
			cycleTrailSpawnDistance = Math.abs(trailSpawnZ - cycle.position.z) + 0.001;
			
			// if the cycle is far enough away from the active trail spawn point, 
			// make the white->cycleColor blended beginning trail start closely following the back wheel of the cycle
			if (cycleTrailSpawnDistance > 1)
				trailBeginningLength = cycleTrailSpawnDistance - 1;
			else 
				trailBeginningLength = 0.001; // else, the trail beginning doesn't have any noticable length yet
			
			// clamp white->cycleColor blended beginning trail (nearest cycle's rear wheel) to a short length of 2 units
			if (trailBeginningLength > 2) trailBeginningLength = 2;
			
			// if the cycle is far enough away from the active trail spawn point, 
			// make the trail wall start following the back wheel of the cycle and the white->cycleColor blended beginning trail
			if (cycleTrailSpawnDistance > 3)
				trailLength = cycleTrailSpawnDistance - 3;
			else 
				trailLength = 0.001; // else, the trail doesn't have any noticable length yet
			
			// clamp trail length to 10 units, which is the maximum length of each trail wall segment
			if (trailLength > 10) trailLength = 10;
			
			trailBeginningVerticalScale = (trailBeginningLength < 1.0) ? trailBeginningLength : 1;
			trailScale = trailLength / 10;
			
			trailBeginning.scale.set(1, trailBeginningVerticalScale, trailBeginningLength);
			trailBeginning.position.set(cycle.position.x, halfTrailHeight, cycle.position.z + 1 + (trailBeginningLength / 2) );
			
			northSouthTrail[0].scale.set(1, 1, trailScale);
			northSouthTrail[0].position.z = trailSpawnZ - (trailLength / 2);
			
			// update cycles components
			// spin wheels
			verticalAngle += cycleSpeed * 12 * frameTime;
			if ( verticalAngle > TWO_PI ) {
				verticalAngle -= TWO_PI;
				flipper = !flipper;
			}
			
			cycle.children[2].material.shininess = 100 * flipper;
			cycle.children[2].rotation.z = 0.004 * flipper;
			
			// update Camera Object
			// clamp vertical camera rotation so the camera doesn't go through the floor
			if ( Math.abs(cameraControlsPitchObject.rotation.x) < 0.1 || 
			     cameraControlsPitchObject.rotation.x > 0.0 ) {
				//cameraControlsPitchObject.rotation.x = -0.1;
			}
					
			// NOTE: camera.translateZ(cameraDistance) must be called when switching cameras
			
			// follow the player's cycle
			//cameraControlsObject.position.copy(cycle.position);
			
			// for cockpit view only
			//cameraControlsObject.translateY(2.5);
			//cameraControlsObject.translateZ(-1);
			
			// update the cycle's matrix now before shadows are set (instead of at render time), 
			// so that the shadows line up exactly with the cycle
			cycle.updateMatrixWorld(true);
				
			// update the ShadowMeshes to follow their shadow-casting objects
			cycleShadow[0].update( groundPlane, lightPosition4D );
			cycleShadow[1].update( groundPlane, lightPosition4D );
			cycleShadow[2].update( groundPlane, lightPosition4D );
			cycleShadow[3].update( groundPlane, lightPosition4D );
			
			northSouthTrailShadow[0].update( groundPlane, lightPosition4D );
			eastWestTrailShadow[0].update( groundPlane, lightPosition4D );
			
			// render the scene with our camera
			renderer.render(scene, camera);
			
			
			
			// real-time debug text output
			//debug1Text.innerHTML = "pitchRotation: " + cameraControlsPitchObject.rotation.x.toFixed(1);
			

		} // end function animate()
		
		
	</script>
</body>

</html>
